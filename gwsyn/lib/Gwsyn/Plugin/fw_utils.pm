package Gwsyn::Plugin::fw_utils;
use Mojo::Base 'Mojolicious::Plugin';

use Mojo::File qw(path);
use Carp;

sub register {
  my ($self, $app, $args) = @_;
  $args ||= {};

  # my $resp = fw_add_replace({id=>11, ip=>'1.2.3.4', mac=>'11:22:33:44:55', defjump=>'ACCEPT'});
  # returns 1-need apply/0-not needed on success,
  #   dies with 'error string' on error,
  $app->helper(fw_add_replace => sub {
    my ($self, $v) = @_;
    croak 'Bad argument' unless $v;

    my $fwfile = path($self->config('firewall_file'));
    my $client_in_chain = $self->config('client_in_chain');
    my $client_out_chain = $self->config('client_out_chain');
    my $fh = eval { $fwfile->open('<') } or die "Can't read firewall file: $!";
    chomp(my @content = <$fh>);
    $fh->close or die "Can't close firewall file: $!";

    # split @content to filter and mangle WITHOUT "COMMIT" lines
    my @filter_content;
    my @mangle_content;
    my $mode = 0;
    for (@content) {
      if (/^\*filter$/x) { $mode = 1; }
      elsif (/^\*mangle$/x) { $mode = 2; }
      if ($mode == 1) {
        if (/^COMMIT$/x) { $mode = 0; next; }
        push @filter_content, $_;
      } elsif ($mode == 2) {
        if (/^COMMIT$/x) { $mode = 0; next; }
        push @mangle_content, $_;
      }
    }
    undef @content;

    $fh = eval { $fwfile->open('>') } or die "Can't reopen firewall file: $!";
    print $fh "# WARNING: this is autogenerated file, don't run or change it!\n\n";
    my $c = "-m comment --comment $v->{id}";
    my $ret = 0; # FIRST ROUND on filter table
    my $ff = 0;
    my $skip = 0;

    for (@filter_content) {
      #*filter
      #:pipe_in_inet_clients - [0:0]
      #:pipe_out_inet_clients - [0:0]
      #:ICMP_ONLY - [0:0]
      #:HTTP_ICMP - [0:0]
      #:HTTP_IM_ICMP - [0:0]
      #-A ICMP_ONLY -p icmp -j ACCEPT etc...
      #
      # 450
      #(1)-A pipe_in_inet_clients -d 192.168.34.23 -m comment --comment 450 -j ACCEPT
      #(2)-A pipe_out_inet_clients -s 192.168.34.23 -m comment --comment 450 -m mac --mac-source 11:22:33:44:55:66 -j ACCEPT
      if ($skip > 0) {
        if (/^-A\ /x) {
          #say "Skipped line ($skip) $_";
          $skip++;
          next;
        } elsif (/^$/x) {
          $skip = 0;
          next;
        } else {
          # here actual replace
          print $fh "# $v->{id}\n";
          print $fh "-A $client_in_chain -d $v->{ip} $c -j $v->{defjump}\n";
          my $m = ($v->{mac}) ? "-m mac --mac-source $v->{mac} " : '';
          print $fh "-A $client_out_chain -s $v->{ip} $c ${m}-j $v->{defjump}\n";
          $skip = 0;
        }
      }
      if (/^\#\ \Q$v->{id}\E$/x) {
        # replace same id but after skip
        #say "Skipped line ($skip) $_";
        $skip = 1;
        $ff = 1;
        $ret = 1;
        next;
      }
      print $fh "$_\n"; # just copy other lines
    }

    if (!$ff or $skip > 0) { # if not found or last line, add new
      print $fh "# $v->{id}\n";
      print $fh "-A $client_in_chain -d $v->{ip} $c -j $v->{defjump}\n";
      my $m = ($v->{mac}) ? "-m mac --mac-source $v->{mac} " : '';
      print $fh "-A $client_out_chain -s $v->{ip} $c ${m}-j $v->{defjump}\n";
      $ret = 1;
    }

    print $fh "COMMIT\n\n"; # AND... NEXT ROUND on mangle table
    $ff = 0;
    $skip = 0;

    for (@mangle_content) {
      #*mangle
      #:pipe_in_inet_clients - [0:0]
      #:pipe_out_inet_clients - [0:0]
      # 450
      #(1)-A pipe_in_inet_clients -d 192.168.34.23 -m comment --comment 450
      #(2)-A pipe_out_inet_clients -s 192.168.34.23 -m comment --comment 450
      if ($skip > 0) {
        if (/^-A\ /x) {
          #say "Skipped line ($skip) $_";
          $skip++;
          next;
        } elsif (/^$/x) {
          $skip = 0;
          next;
        } else {
          # here actual replace
          print $fh "# $v->{id}\n";
          print $fh "-A $client_in_chain -d $v->{ip} $c\n";
          print $fh "-A $client_out_chain -s $v->{ip} $c\n";
          $skip = 0;
        }
      }
      if (/^\#\ \Q$v->{id}\E$/x) {
        # replace same id but after skip
        #say "Skipped line ($skip) $_";
        $skip = 1;
        $ff = 1;
        $ret = 1;
        next;
      }
      print $fh "$_\n"; # just copy other lines
    }

    if (!$ff or $skip > 0) { # if not found or last line, add new
      print $fh "# $v->{id}\n";
      print $fh "-A $client_in_chain -d $v->{ip} $c\n";
      print $fh "-A $client_out_chain -s $v->{ip} $c\n";
      $ret = 1;
    }

    print $fh "COMMIT\n";

    $fh->close or die "Can't close firewall file: $!";

    return $ret;
  });


  # my $resp = fw_delete($id);
  # returns 1-need apply/0-not needed on success,
  #   dies with 'error string' on error
  $app->helper(fw_delete => sub {
    my ($self, $id) = @_;
    croak 'Bad argument' unless defined $id;

    my $fwfile = path($self->config('firewall_file'));
    my $fh = eval { $fwfile->open('<') } or die "Can't read firewall file: $!";
    chomp(my @content = <$fh>);
    $fh->close or die "Can't close firewall file: $!";

    $fh = eval { $fwfile->open('>') } or die "Can't reopen firewall file: $!";
    my $ret = 0;
    my $skip = 0;

    for (@content) {
      # WARNING: this is autogenerated file, don't run or change it!
      #*filter
      #:pipe_in_inet_clients - [0:0]
      #:pipe_out_inet_clients - [0:0]
      #:ICMP_ONLY - [0:0]
      #:HTTP_ICMP - [0:0]
      #:HTTP_IM_ICMP - [0:0]
      #-A ICMP_ONLY -p icmp -j ACCEPT etc...
      #
      # 450
      #(1)-A pipe_in_inet_clients -d 192.168.34.23 -m comment --comment 450 -j ACCEPT
      #(2)-A pipe_out_inet_clients -s 192.168.34.23 -m comment --comment 450 -m mac --mac-source 11:22:33:44:55:66 -j ACCEPT
      #COMMIT
      #
      #*mangle
      #:pipe_in_inet_clients - [0:0]
      #:pipe_out_inet_clients - [0:0]
      # 450
      #(1)-A pipe_in_inet_clients -d 192.168.34.23 -m comment --comment 450
      #(2)-A pipe_out_inet_clients -s 192.168.34.23 -m comment --comment 450
      #COMMIT
      if ($skip > 0) {
        if (/^-A\ /x) {
          #say "Skipped line ($skip) $_";
          $skip++;
          next;
        } elsif (/^$/x) {
          $skip = 0;
          next;
        } else {
          $skip = 0;
        }
      }
      if (/^\#\ \Q$id\E$/x) {
        #say "Skipped line ($skip) $_";
        $skip = 1;
        $ret = 1;
        next;
      }
      print $fh "$_\n"; # just copy other lines
    }

    $fh->close or die "Can't close firewall file: $!";

    return $ret;
  });


  # my $resp = fw_create_full([{id=>11, ip=>'1.2.3.4', mac=>'11:22:33:44:55', defjump=>'ACCEPT'}, ...]);
  # fully updates /var/r2d2/firewall.clients,
  # returns 1-need apply/0-not needed on success,
  #   dies with 'error string' on error,
  #   will check mac and add line without it if not set.
  $app->helper(fw_create_full => sub {
    my ($self, $va) = @_;
    croak 'Bad argument' unless $va;

    my $fwfile = path($self->config('firewall_file'));
    my $client_in_chain = $self->config('client_in_chain');
    my $client_out_chain = $self->config('client_out_chain');
    my $prof = $self->config('my_profile');

    my $fh = eval { $fwfile->open('>') } or die "Can't create firewall file: $!";

    print $fh "# WARNING: this is autogenerated file, don't run or change it!\n\n";
    print $fh "*filter\n";
    print $fh ":$client_in_chain - [0:0]\n";
    print $fh ":$client_out_chain - [0:0]\n";
    print $fh ":ICMP_ONLY - [0:0]\n";
    print $fh ":HTTP_ICMP - [0:0]\n";
    print $fh ":HTTP_IM_ICMP - [0:0]\n";
    print $fh "-A ICMP_ONLY -p icmp -j ACCEPT\n";
    print $fh "-A HTTP_ICMP -p icmp -j ACCEPT\n";
    print $fh "-A HTTP_ICMP -p tcp -m multiport --source-ports 80,8080,81,3128,443 -j ACCEPT\n";
    print $fh "-A HTTP_ICMP -p tcp -m multiport --destination-ports 80,8080,81,3128,443 -j ACCEPT\n";
    print $fh "-A HTTP_IM_ICMP -p icmp -j ACCEPT\n";
    print $fh "-A HTTP_IM_ICMP -p tcp -j HTTP_ICMP\n";
    print $fh "-A HTTP_IM_ICMP -p tcp -m multiport --source-ports 25,110,995,143,993,119,563,5190,5222,5223,1863 -j ACCEPT\n";
    print $fh "-A HTTP_IM_ICMP -p tcp -m multiport --destination-ports 25,110,995,143,993,119,563,5190,5222,5223,1863 -j ACCEPT\n";
    print $fh "\n";

    # data
    my $mangle_append = '';
    for (@$va) {
      next if (!$_->{profile} or $_->{profile} ne $prof); # skip clients from invalid profiles
      print $fh "# $_->{id}\n";
      my $c = "-m comment --comment $_->{id}";
      print $fh "-A $client_in_chain -d $_->{ip} $c -j $_->{defjump}\n";
      my $m = ($_->{mac}) ? "-m mac --mac-source $_->{mac} " : '';
      print $fh "-A $client_out_chain -s $_->{ip} $c ${m}-j $_->{defjump}\n";
      $mangle_append .= "# $_->{id}\n";
      $mangle_append .= "-A $client_in_chain -d $_->{ip} $c\n";
      $mangle_append .= "-A $client_out_chain -s $_->{ip} $c\n";
    }
    print $fh "COMMIT\n\n";
    print $fh "*mangle\n";
    print $fh ":$client_in_chain - [0:0]\n";
    print $fh ":$client_out_chain - [0:0]\n";
    print $fh $mangle_append;
    print $fh "COMMIT\n";

    $fh->close or die "Can't close firewall file: $!";

    # always need apply
    return 1;
  });


  # my $err = $app->fw_apply()
  # returns 1-success, dies on error
  $app->helper(fw_apply => sub {
    my $self = shift;

    # reload rules with iptables_restore
    my $rulefile = $self->config('firewall_file');
    # note: iptables_restore still flushes user chains mentioned in file
    if (!$self->system(iptables_restore => "--noflush < $rulefile")) {
      return 1; # success
    } else {
      die "iptables_restore error";
    }
  });

}

1;
